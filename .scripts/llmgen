#! /usr/bin/env python3

import requests
import json
import argparse
import os

import re
from concurrent.futures import ThreadPoolExecutor, as_completed

SERVER_IP = "10.215.192.82"
SERVER_PORT = 8721
MODEL_NAME="gpt-oss-120b"
CONFIG_DIR = os.path.expanduser("~/.scripts/prompts")


def load_prompt(prompt_name):
    prompt_file = os.path.join(CONFIG_DIR, f"{prompt_name}.txt")
    if not os.path.exists(prompt_file):

        raise FileNotFoundError(f"Prompt file {prompt_file} not found")
    with open(prompt_file, 'r', encoding='utf-8') as f:
        return f.read()


def read_file_content(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return f.read()

def write_result(result, filename, inplace, to_markdown, prompt_name):
    if inplace:
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(result)
    elif to_markdown:
        md_path = os.path.splitext(filename)[0] + "-" + prompt_name + ".md"
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(result)
        print(f"üìù Wrote Markdown output to {md_path}")

    else:
        print(f"\n=== Output for {filename} ===\n")
        print(result)

def process_file(filename, prompt, index, inplace, to_markdown, prompt_name):
    try:
        content = read_file_content(filename)
        payload = {
            "model": MODEL_NAME,
            "messages": [
                {"role": "system", "content": prompt},
                {"role": "user", "content": content}
            ],
            "temperature": 0.6,
            "top_p": 0.95,
            "top_k": 20
        }

        response = requests.post(
            f"http://{SERVER_IP}:{SERVER_PORT}/v1/chat/completions",
            headers={"Content-Type": "application/json"},
            data=json.dumps(payload),
            timeout=1200
        )

        if response.status_code != 200:
            raise RuntimeError(f"HTTP {response.status_code}: {response.text}")

        data = response.json()
        if 'choices' not in data or not data['choices']:
            raise ValueError("Invalid response: no choices")


        result = data['choices'][0]['message']['content']
        
        print(f"[{index+1}] ‚úÖ Processed {filename}")
        write_result(result, filename, inplace, to_markdown, prompt_name)
        return index, result, filename


    except Exception as e:
        print(f"[{index+1}] ‚ùå Error processing {filename}: {e}")
        error_result = f"<!-- Error processing {filename}: {e} -->"
        write_result(error_result, filename, inplace, to_markdown, prompt_name)
        return index, error_result, filename

def process_files(filenames, prompt_name, inplace, to_markdown, workers):
    prompt = load_prompt(prompt_name)
    print(f"üìÑ Processing {len(filenames)} file(s) with prompt '{prompt_name}'")
    if inplace:
        print("‚úçÔ∏è In-place mode enabled.")

    if to_markdown:
        print("üìù Markdown output mode enabled.")

    with ThreadPoolExecutor(max_workers=workers) as executor:
        futures = [
            executor.submit(process_file, filename, prompt, idx, inplace, to_markdown, prompt_name)
            for idx, filename in enumerate(filenames)
        ]
        
        for future in as_completed(futures):

            future.result()  # Just wait for completion, results are already written

def main():
    parser = argparse.ArgumentParser(
        description="Process files with LLM using configurable prompts",
        allow_abbrev=False
    )
    parser.add_argument('filenames', nargs='+', help='Input file(s)')
    parser.add_argument('--prompt', default='default', help='Prompt name (without .txt)')
    parser.add_argument('--inplace', action='store_true', help='Modify files in place')
    parser.add_argument('--markdown', action='store_true', help='Write output to markdown')
    parser.add_argument('--workers', type=int, default=16, help='Number of workers')

    args = parser.parse_args()


    if not os.path.exists(CONFIG_DIR):
        raise FileNotFoundError(f"Config directory '{CONFIG_DIR}' not found")

    for filename in args.filenames:

        if not os.path.exists(filename):
            raise FileNotFoundError(f"Input file {filename} not found")

    if args.inplace and args.markdown:

        raise ValueError("Cannot use --inplace and --markdown together")

    process_files(args.filenames, args.prompt, args.inplace, args.markdown, args.workers)

if __name__ == '__main__':
    main()

